---
title: C++  总结 
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---

[TOC]



##  多态性
[多种多态性][1]

[浅谈 C++ 多态性][2]

多态性即 **“一个接口，多种方法”**，程序运行时才决定调用的函数。
1、静态多态性：指定义在一个类或函数中的同名函数，根据参数表区别语义，通过静态联编实现。
2、动态多态性：指定义在一个类层次的不同类中的重载函数，具有相同的函数，根据指针指向的对象所在的类来区别语义，通过动态联编实现。

**纯虚函数和虚函数**
纯虚函数一定没有定义，用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，可以声明指向该抽象类的具体类的指针或引用。

虚函数必须声明，如果不实现，编译报错
* 对于虚函数来说，父类和子类都有各自的版本，由多态方式调用的时候动态绑定
* 实现了纯虚函数的子类，该纯虚函数在子类就变成了虚函数，子类的子类可以覆盖
* 虚函数是 `C++` 中实现多态的机制，核心理念就是通过基类访问派生类定义的函数。


##  动态绑定和静态绑定
[深入理解 C++ 的动态绑定和静态绑定][3]

**对象的静态类型：** 对象在声明时采用的类型，是在编译期确定的。
**对象的动态类型：** 目前所指对象类型。在运行期决定，动态类型可以改变，静态类型无法改变。

**静态绑定：** 绑定的是对象的静态类型，某特性(比如函数)依赖于对象的静态类型，发生在编译期。
**动态绑定：** 绑定的是对象的动态类型，某特性(比如函数)依赖于对象的动态类型，发生在运行期。


##  类型转换
* `const_cast` 用来将对象的常量性移除
* `dynamic_cast` 用来执行 “安全向下转型”



##  对象模型
[《深度探索C++对象模型》笔记汇总][4]

[C++对象模型][5]

`C++` 类包含两种数据成员：**静态数据成员** 和 **非静态数据成员**，三种成员函数：**成员函数**、**静态函数** 和 **虚函数**，共有三种对象模型：**简单对象模型**、**表格驱动对象模型** 和 **`C++` 对象模型**。


##  内存对齐的原则
[内存对齐的规则以及作用][6]

[内存对齐全攻略--涉及位域的内存对齐原则][7]


##  C++ 模板
[C++模板][8]

[C++模板学习][9]


##  `I/O` 多路复用 `select、poll、epoll` 的区别
[I/O多路复用select、poll、epoll的区别使用][10]

[`Redis I/O` 多路复用 ][11]

`I/O` 多路复用技术为了解决进程或线程阻塞到某个 `I/O` 系统调用而出现的技术，使进程不阻塞于某个特定 `I/O` 系统调用。


##  内联函数
[内联函数][12]

内联函数是指定义在类体内的成员函数
* 函数代码被放入符号表中，使用时直接进行替换，没有调用的开销，效率高
* 可以使用类的保护成员及私有成员
* 避免宏定义容易产生二义性问题(`#define ABS(x) ((x)>0?(x):(-x))` 会加2次)

**内联函数和宏的区别**
* 宏是由预处理器对宏进行替换，内联函数由编译期实现，取消了函数的参数压栈，减少了调用开销
* 内联函数遵循类型和作用域规则

可以使用 `inline` 来定义内联函数。

##  函数调用
[ 深入理解C语言的函数调用过程 ][13]

调用之前保存栈空间，里面是局部变量，还有保存下一个要执行的地址，再传递函数参数

## `extern C` 作用
[`extern C` 作用详解][14]

主要为了能够正确实现 `C++` 调用 C 语言代码，指示编译器这部分代码按照 C 语言进行编译。
在 C++ 出现之前，很多代码都是 C 语言写的，为了更好的支持原来的 C 代码和已经写好的C语言库，在 C++ 中尽可能支持 C。


##  `Reactor` 模式
[使用I/O多路复用技术--select实现Reactor模式][15]

[两种高性能I/O设计模式(Reactor/Proactor)的比较][16]










##  同步异步
[网络编程释疑之：同步，异步，阻塞，非阻塞][17]

[怎样理解阻塞非阻塞与同步异步的区别][18]


阻塞，非阻塞：进程/线程访问数据是否就绪，进程/线程是否需要等待
同步，异步：关注的是 **消息通信机制**；
同步：在发出一个调用时，在没有得到结果之前，该调用不会返回，但是一旦调用返回，就得到返回值。
异步：调用在发出后，调用直接返回，所以没有返回结果；而是有被调用者通过状态、通知来通知调用者，或者通过回调函数处理这个调用。



##  管道，进程通信


##  多线程


##  TCP/UDP


  [1]: http://blog.csdn.net/fengyunjh/article/details/6188769
  [2]: http://blog.csdn.net/hackbuteer1/article/details/7475622
  [3]: http://blog.csdn.net/chgaowei/article/details/6427731
  [4]: http://www.roading.org/develop/cpp/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB.html
  [5]: http://www.cnblogs.com/skynet/p/3343726.html
  [6]: http://www.cppblog.com/snailcong/archive/2009/03/16/76705.html
  [7]: http://www.cnblogs.com/shitouer/archive/2010/04/07/1706785.html
  [8]: http://www.cnblogs.com/gw811/archive/2012/10/25/2738929.html
  [9]: http://www.cnblogs.com/gaojun/archive/2010/09/10/1823354.html
  [10]: http://www.bkjia.com/ASPjc/1000957.html#top
  [11]: https://www.zhihu.com/question/28594409
  [12]: http://www.cnblogs.com/singa/archive/2008/09/24/1297821.html
  [13]: http://blog.chinaunix.net/uid-23069658-id-3981406.html
  [14]: http://blog.csdn.net/jiqiren007/article/details/5933599
  [15]: http://www.rudy-yuan.net/archives/137/
  [16]: http://blog.jobbole.com/59676/
  [17]: http://yaocoder.blog.51cto.com/2668309/1308899
  [18]: https://www.zhihu.com/question/19732473