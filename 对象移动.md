---
title: 对象移动
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---


[TOC]

新标准的一个最主要的特性是可以移动而非拷贝对象的能力。移动而非拷贝对象会大幅度提升性能。`IO` 类或 `unique_ptr` 类型的对象不能拷贝只能移动。

##  右值引用
通过 `&&` 获得右值引用。只能绑定到一个**将要销毁的对象**。如**表达式、字面量或返回右值的表达式。不能将一个右值引用直接绑定到一个左值上**。

![图一][1]

**左值持久：右值短暂**
左值有持久的状态，右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。

**变量是左值**
变量表达式都是左值，右值变量也是左值；不能将右值引用绑定到一个右值引用类型的变量上。

![enter description here][2]

**标准 `move` 函数**
可以显式地**将一个左值转换为对应的右值引用类型**。
```cpp?linenums
int &&r = std::move(rr);  // ok
```
**使用 `move` 的代码应该使用 `std::move` 而不是 `move`。这样可以避免潜在的名字冲突。**

**移动构造函数和移动赋值运算符**
移动构造函数的第一个参数是该类类型的一个引用。是一个右值引用，与拷贝构造函数一样，任何额外的参数都必须有默认实参。

![enter description here][3]

与拷贝构造函数不同，移动构造函数不分配新内存；它接管给定的 `StrVec` 中的内存。在接管内存之后，它将给定对象中的指针都置为 `nullptr`。这样完成了从给定对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行析构函数。 `StrVec` 的析构函数在 `first_free` 上调用 `deallocate`。如果忘记改变 `s.first_free`，则销毁移后源对象就会释放掉我们刚刚移动的内存。

**移动操作、标准容器和异常( `noexcept` )**
避免为了处理可能的异常做一些额外的工作。
标准库容器能对异常发生时其自身的行为提供保障。















































  [1]: ./images/1460688932816.jpg "1460688932816.jpg"
  [2]: ./images/1460689254262.jpg "1460689254262.jpg"
  [3]: ./images/1460690635450.jpg "1460690635450.jpg"